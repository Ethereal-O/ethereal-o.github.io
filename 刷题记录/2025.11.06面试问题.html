<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Ethereal">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/刷题记录/2025.11.06面试问题.html"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="知识列表一、基础语法与数据类型1. 核心数据类型 基本类型：char(1字节)、short(2字节)、int(4字节)、long(4&#x2F;8字节，取决于平台)、long long(8字节)、float(4字节)、double(8字节)、bool(1字节)；无符号版本（unsigned）仅扩大正数范围（如unsigned int范围0~4294967295，int范围-2147483648~214748">
<meta property="og:type" content="website">
<meta property="og:title" content="251106面试问题">
<meta property="og:url" content="http://example.com/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/2025.11.06%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="知识列表一、基础语法与数据类型1. 核心数据类型 基本类型：char(1字节)、short(2字节)、int(4字节)、long(4&#x2F;8字节，取决于平台)、long long(8字节)、float(4字节)、double(8字节)、bool(1字节)；无符号版本（unsigned）仅扩大正数范围（如unsigned int范围0~4294967295，int范围-2147483648~214748">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-11-15T13:33:00.000Z">
<meta property="article:modified_time" content="2025-11-15T12:16:04.334Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            251106面试问题 -
        
        Ethereal&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/fonts/fonts.css">

    
<link rel="stylesheet" href="/fonts/Satoshi/satoshi.css">

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">

    <!--- Font Part-->
    
    
    
    

    <!--- Inject Part-->
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":true,"google_analytics":{"enable":false,"id":null},"website_counter":{"url":"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Welcome to Ethereal's Blog","subtitle":{"text":["A willing horse needs no spur."],"hitokoto":{"enable":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.2.1","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Github":{"path":"https://github.com/Ethereal-O/","icon":"fa-brands fa-github"},"CSDN":{"path":"https://blog.csdn.net/weixin_51969975","icon":"fa-brands fa-stack-overflow"},"Links":{"icon":"fa-regular fa-link","submenus":{"Fontawesome":"https://fontawesome.com/search","Iconfont":"https://www.iconfont.cn/","Redefine":"https://redefine-docs.ohevan.com/introduction","Linyu":"https://www.linyu.cool/","Electronic-Waste":"https://blog.electronicwaste.cn/?","Thysrael":"https://thysrael.github.io/?","World-explorer":"https://www.cnblogs.com/world-explorer"}}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"links":null},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/8/1 00:00:00"};
    Global.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    Global.data_config = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Ethereal&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    target="_blank" rel="noopener" href="https://github.com/Ethereal-O/"  >
                                    
                                        
                                            <i class="fa-brands fa-github"></i>
                                        
                                        GITHUB
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51969975"  >
                                    
                                        
                                            <i class="fa-brands fa-stack-overflow"></i>
                                        
                                        CSDN
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        LINKS&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://fontawesome.com/search">FONTAWESOME
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://www.iconfont.cn/">ICONFONT
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://redefine-docs.ohevan.com/introduction">REDEFINE
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://www.linyu.cool/">LINYU
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://blog.electronicwaste.cn/?">ELECTRONIC-WASTE
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://thysrael.github.io/?">THYSRAEL
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://www.cnblogs.com/world-explorer">WORLD-EXPLORER
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        target="_blank" rel="noopener" href="https://github.com/Ethereal-O/"  >
                             
                                
                                    <i class="fa-brands fa-github"></i>
                                
                                GITHUB
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51969975"  >
                             
                                
                                    <i class="fa-brands fa-stack-overflow"></i>
                                
                                CSDN
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                LINKS&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://fontawesome.com/search">FONTAWESOME</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://www.iconfont.cn/">ICONFONT</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://redefine-docs.ohevan.com/introduction">REDEFINE</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://www.linyu.cool/">LINYU</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://blog.electronicwaste.cn/?">ELECTRONIC-WASTE</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://thysrael.github.io/?">THYSRAEL</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://www.cnblogs.com/world-explorer">WORLD-EXPLORER</a>
                            </li>
                        
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="page-template-container">
        
        
        
        <div class="page-template-content markdown-body">
            
                <h2 id="知识列表"><a href="#知识列表" class="headerlink" title="知识列表"></a>知识列表</h2><h3 id="一、基础语法与数据类型"><a href="#一、基础语法与数据类型" class="headerlink" title="一、基础语法与数据类型"></a>一、基础语法与数据类型</h3><h4 id="1-核心数据类型"><a href="#1-核心数据类型" class="headerlink" title="1. 核心数据类型"></a>1. 核心数据类型</h4><ul>
<li><p><strong>基本类型</strong>：<code>char(1字节)</code>、<code>short(2字节)</code>、<code>int(4字节)</code>、<code>long(4/8字节，取决于平台)</code>、<code>long long(8字节)</code>、<code>float(4字节)</code>、<code>double(8字节)</code>、<code>bool(1字节)</code>；无符号版本（<code>unsigned</code>）仅扩大正数范围（如<code>unsigned int</code>范围<code>0~4294967295</code>，<code>int</code>范围<code>-2147483648~2147483647</code>）。</p>
</li>
<li><p><strong>类型转换</strong>：</p>
<ul>
<li><p>隐式转换：编译器自动完成（如<code>int</code>→<code>double</code>、子类指针→父类指针），可能导致窄化（如<code>double</code>→<code>int</code>丢失精度）；</p>
</li>
<li><p>显式转换（面试高频）：</p>
<ul>
<li><p><code>static_cast</code>：相关类型转换（如<code>int</code>→<code>char</code>、父类指针→子类指针，无运行期检查），不能移除<code>const</code>；</p>
</li>
<li><p><code>dynamic_cast</code>：多态类型向下转换（子类指针→父类指针），运行期检查类型兼容性，失败返回<code>nullptr</code>（指针）&#x2F;抛出异常（引用），需依赖虚函数；</p>
</li>
<li><p><code>const_cast</code>：仅移除变量的<code>const/volatile</code>属性，仅适用于指针&#x2F;引用（如<code>const int* p → int*</code>），修改原常量会触发未定义行为；</p>
</li>
<li><p><code>reinterpret_cast</code>：底层二进制强制转换（如<code>int</code>→<code>void*</code>、指针→整数），不检查类型关联性，风险极高，仅用于底层开发。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>typedef与using</strong>：</p>
<ul>
<li><p><code>typedef</code>：定义类型别名（<code>typedef int MyInt;</code>），不支持模板别名；</p>
</li>
<li><p><code>using</code>（C++11+）：更灵活，支持模板别名（<code>template&lt;typename T&gt; using Vec = std::vector&lt;T&gt;;</code>），优先级高于<code>typedef</code>。</p>
</li>
</ul>
</li>
<li><p>关键字与标识符：<code>const</code>, <code>mutable</code>, <code>volatile</code>, <code>register</code>, <code>explicit</code> 等</p>
</li>
</ul>
<h4 id="2-变量存储区域"><a href="#2-变量存储区域" class="headerlink" title="2. 变量存储区域"></a>2. 变量存储区域</h4><ul>
<li><p>栈（Stack）：存储局部变量、函数参数，自动分配&#x2F;释放（函数调用时入栈，返回时出栈），空间小（通常几MB），溢出会触发栈崩溃；</p>
</li>
<li><p>堆（Heap）：动态内存区域，需手动通过<code>new/malloc</code>分配、<code>delete/free</code>释放，空间大（可达GB级），未释放会导致内存泄漏；</p>
</li>
<li><p>全局&#x2F;静态区（Data Segment）：存储全局变量、<code>static</code>变量，程序启动时分配，退出时释放，默认初始化为0；</p>
</li>
<li><p>常量区（RoData）：存储字符串常量（如<code>&quot;hello&quot;</code>）、<code>const</code>常量，只读，修改会触发段错误；</p>
</li>
<li><p>代码区（Code Segment）：存储程序指令，只读，避免被篡改。</p>
</li>
</ul>
<h4 id="3-函数核心特性"><a href="#3-函数核心特性" class="headerlink" title="3. 函数核心特性"></a>3. 函数核心特性</h4><ul>
<li><p><strong>函数签名</strong>：由「函数名 + 参数列表（类型、个数、顺序） + cv限定符（<code>const/volatile</code>） + 引用限定符（<code>&amp;/&amp;&amp;</code>）」构成，<strong>返回值不参与签名</strong>（如<code>int add(int)</code>和<code>double add(int)</code>编译冲突）。</p>
</li>
<li><p><strong>重载（Overload）</strong>：同一作用域内，函数名相同、签名不同（参数差异），编译期决议（根据实参匹配）；注意：仅返回值&#x2F;默认参数不同不能重载。</p>
</li>
<li><p><strong>重写（Override）</strong>：子类重写父类的虚函数，需满足「三同」（函数名、参数列表、返回值一致），父类函数必须带<code>virtual</code>，运行期多态（通过虚表决议）。</p>
</li>
<li><p><strong>隐藏（Hide）</strong>：子类函数与父类函数同名但不满足重写条件（如父类无<code>virtual</code>、参数不同），父类函数被隐藏（子类调用时优先自身，需显式<code>父类::函数名</code>调用）。</p>
</li>
<li><p><strong>内联函数（inline）</strong>：</p>
<ul>
<li><p>编译期将函数体嵌入调用处，减少函数调用开销（栈帧创建&#x2F;销毁），适用于短小函数（1-5行）；</p>
</li>
<li><p>限制：不能包含循环&#x2F;递归&#x2F;switch，声明与定义需在同一文件（否则触发链接错误）；</p>
</li>
<li><p>与宏区别：类型安全、有作用域限制，宏仅文本替换（无类型检查，易引发副作用）。</p>
</li>
</ul>
</li>
<li><p><strong>constexpr函数（C++11+）</strong>：编译期计算结果，返回值为常量表达式，可用于数组大小、模板参数等编译期场景（如<code>constexpr int pow2(int n) &#123; return 1 &lt;&lt; n; &#125;</code>，<code>int arr[pow2(3)]</code>合法）。</p>
</li>
<li><p><strong>默认参数与可变参数</strong>：</p>
<ul>
<li><p>默认参数：从右往左指定（<code>void f(int a, int b=2)</code>合法，<code>void f(int a=1, int b)</code>非法），调用时可省略默认参数；</p>
</li>
<li><p>可变参数：<code>...</code>（C风格）或<code>std::initializer_list</code>（C++11+，类型安全），如<code>void sum(std::initializer_list&lt;int&gt; nums)</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="二、类与对象（OOP核心）：三五法则（Rule-of-Five）"><a href="#二、类与对象（OOP核心）：三五法则（Rule-of-Five）" class="headerlink" title="二、类与对象（OOP核心）：三五法则（Rule of Five）"></a>二、类与对象（OOP核心）：三五法则（Rule of Five）</h3><h4 id="1-类与结构体本质区别"><a href="#1-类与结构体本质区别" class="headerlink" title="1. 类与结构体本质区别"></a>1. 类与结构体本质区别</h4><p>仅「默认访问权限」和「默认继承方式」不同，其他语法完全一致（支持继承、多态、虚函数）：</p>
<ul>
<li><p><code>struct</code>：成员默认<code>public</code>，默认<code>public</code>继承；</p>
</li>
<li><p><code>class</code>：成员默认<code>private</code>，默认<code>private</code>继承。</p>
</li>
</ul>
<h4 id="2-构造与析构函数"><a href="#2-构造与析构函数" class="headerlink" title="2. 构造与析构函数"></a>2. 构造与析构函数</h4><ul>
<li><p><strong>构造函数</strong>：</p>
<ul>
<li><p>无返回值，与类名相同，可重载（默认构造、拷贝构造、移动构造、带参构造）；</p>
</li>
<li><p>默认构造：无参或全默认参数（<code>A() &#123;&#125;</code>或<code>A(int a=0) &#123;&#125;</code>），未显式定义时编译器自动生成；</p>
</li>
<li><p>拷贝构造：参数为<code>const 本类&amp;</code>（<code>A(const A&amp; other)</code>），未显式定义时编译器生成浅拷贝（仅复制成员变量，指针指向同一内存）；</p>
</li>
<li><p>移动构造（C++11+）：参数为<code>本类&amp;&amp;</code>（<code>A(A&amp;&amp; other)</code>），转移资源所有权（如指针指向的堆内存），避免拷贝，效率高；</p>
</li>
<li><p>委托构造函数（C++11）:调用其他构造函数</p>
</li>
<li><p>初始化列表：<code>A(int a, int b) : x(a), y(b) &#123;&#125;</code>，必须用于<code>const</code>成员、引用成员、无默认构造的成员变量（初始化顺序与成员声明顺序一致，与列表顺序无关）。</p>
</li>
</ul>
</li>
<li><p><strong>析构函数</strong>：</p>
<ul>
<li><p>格式<code>~类名()</code>，无参数无返回值，仅一个，未显式定义时编译器自动生成；</p>
</li>
<li><p>核心用途：释放资源（堆内存、文件句柄、锁），父类析构必须加<code>virtual</code>（否则子类析构不会被调用，导致资源泄漏）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-拷贝赋值与移动赋值"><a href="#3-拷贝赋值与移动赋值" class="headerlink" title="3. 拷贝赋值与移动赋值"></a>3. 拷贝赋值与移动赋值</h4><ul>
<li><p><strong>拷贝赋值运算符</strong>：<code>A&amp; operator=(const A&amp; other)</code>，深拷贝实现（复制资源，避免浅拷贝导致的双重释放）；</p>
</li>
<li><p><strong>移动赋值运算符</strong>：<code>A&amp; operator=(A&amp;&amp; other) noexcept</code>，转移资源（如<code>this-&gt;ptr = other.ptr; other.ptr = nullptr;</code>），无拷贝开销；</p>
</li>
<li><p>三&#x2F;五法则（面试高频）：</p>
<ul>
<li><p>三法则：若需显式定义「拷贝构造、拷贝赋值、析构」中的一个，必须显式定义另外两个（避免资源管理不一致）；</p>
</li>
<li><p>五法则（C++11+）：在三法则基础上，增加「移动构造、移动赋值」，需确保移动操作不抛异常（<code>noexcept</code>）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-类成员修饰符"><a href="#4-类成员修饰符" class="headerlink" title="4. 类成员修饰符"></a>4. 类成员修饰符</h4><ul>
<li><p><strong>static成员</strong>：</p>
<ul>
<li><p>属于类而非对象，所有对象共享一份内存，程序启动时初始化（全局&#x2F;静态区）；</p>
</li>
<li><p><code>static</code>成员函数无<code>this</code>指针，不能访问非<code>static</code>成员（变量&#x2F;函数），可通过「类名::成员名」直接调用。</p>
</li>
</ul>
</li>
<li><p><strong>const成员</strong>：</p>
<ul>
<li><p><code>const</code>成员变量：只能通过初始化列表赋值，生命周期与对象一致；</p>
</li>
<li><p><code>const</code>成员函数：<code>void f() const</code>，不能修改非<code>mutable</code>成员变量，不能调用非<code>const</code>成员函数（保证对象只读）。</p>
</li>
</ul>
</li>
<li><p><strong>mutable关键字</strong>：允许<code>const</code>成员函数修改该变量（如缓存数据、统计调用次数，<code>mutable int count;</code>）。</p>
</li>
<li><p><strong>friend关键字</strong>：友元函数&#x2F;类可访问当前类的<code>private/protected</code>成员，打破封装性，需谨慎使用（如运算符重载、工具类）。</p>
</li>
</ul>
<h3 id="三、继承与多态（OOP核心扩展）"><a href="#三、继承与多态（OOP核心扩展）" class="headerlink" title="三、继承与多态（OOP核心扩展）"></a>三、继承与多态（OOP核心扩展）</h3><h4 id="1-继承方式与访问控制"><a href="#1-继承方式与访问控制" class="headerlink" title="1. 继承方式与访问控制"></a>1. 继承方式与访问控制</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>继承方式</td>
<td>父类public成员</td>
<td>父类protected成员</td>
<td>父类private成员</td>
</tr>
<tr>
<td>public</td>
<td>子类public</td>
<td>子类protected</td>
<td>不可访问</td>
</tr>
<tr>
<td>protected</td>
<td>子类protected</td>
<td>子类protected</td>
<td>不可访问</td>
</tr>
<tr>
<td>private</td>
<td>子类private</td>
<td>子类private</td>
<td>不可访问</td>
</tr>
</tbody></table>
<h4 id="2-多态实现原理"><a href="#2-多态实现原理" class="headerlink" title="2. 多态实现原理"></a>2. 多态实现原理</h4><ul>
<li><p><strong>核心条件</strong>：父类虚函数（<code>virtual</code>） + 子类重写 + 父类指针&#x2F;引用指向子类对象；</p>
</li>
<li><p><strong>虚表（vtable）与虚指针（vptr）</strong>：</p>
<ul>
<li><p>带虚函数的类会生成虚表（存储所有虚函数的地址，全局唯一）；</p>
</li>
<li><p>每个对象会包含一个虚指针（<code>vptr</code>，通常在对象首地址），指向所属类的虚表；</p>
</li>
<li><p>子类继承父类的虚表，并重写的虚函数会覆盖虚表中对应的地址；</p>
</li>
<li><p>调用虚函数时，通过<code>vptr</code>找到虚表，再调用对应函数地址（运行期决议）。</p>
</li>
</ul>
</li>
<li><p><strong>纯虚函数与抽象类</strong>：</p>
<ul>
<li><p>纯虚函数：<code>virtual void f() = 0;</code>，无函数体；</p>
</li>
<li><p>抽象类：含纯虚函数的类，不能实例化，仅用于继承（子类需重写所有纯虚函数才能实例化）。</p>
</li>
</ul>
</li>
<li><p><strong>final与override（C++11+）</strong>：</p>
<ul>
<li><p><code>final</code>：修饰类→禁止继承；修饰虚函数→禁止子类重写；</p>
</li>
<li><p><code>override</code>：显式声明重写父类虚函数，编译器检查正确性（避免拼写错误、参数不匹配）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-菱形继承问题与解决方案"><a href="#3-菱形继承问题与解决方案" class="headerlink" title="3. 菱形继承问题与解决方案"></a>3. 菱形继承问题与解决方案</h4><ul>
<li><p><strong>问题</strong>：多继承时子类间接继承同一父类（如<code>A→B</code>、<code>A→C</code>、<code>B→D</code>、<code>C→D</code>），导致：</p>
<ul>
<li><p>数据冗余（<code>D</code>对象包含两份<code>A</code>的成员）；</p>
</li>
<li><p>二义性（<code>D obj; obj.a</code>无法确定访问哪份<code>A</code>的成员）；</p>
</li>
</ul>
</li>
<li><p><strong>解决方案</strong>：虚继承（<code>virtual</code>），让父类成为共享基类（仅一份成员）：</p>
<pre><code>class B : virtual public A &#123;&#125;;class C : virtual public A &#123;&#125;;class D : public B, public C &#123;&#125;; // D仅含一份A的成员
</code></pre>
</li>
</ul>
<h3 id="四、模板与泛型编程（C-核心特性）"><a href="#四、模板与泛型编程（C-核心特性）" class="headerlink" title="四、模板与泛型编程（C++核心特性）"></a>四、模板与泛型编程（C++核心特性）</h3><h4 id="1-函数模板与类模板"><a href="#1-函数模板与类模板" class="headerlink" title="1. 函数模板与类模板"></a>1. 函数模板与类模板</h4><ul>
<li><p><strong>函数模板</strong>：</p>
<pre><code>template&lt;typename T&gt; // 或template&lt;class T&gt;，typename与class等价T add(T a, T b) &#123; return a + b; &#125;
</code></pre>
<ul>
<li><p>编译器根据实参类型自动实例化（如<code>add(1,2)</code>→<code>int add(int, int)</code>，<code>add(1.2,3.4)</code>→<code>double add(double, double)</code>）；</p>
</li>
<li><p>支持显式指定类型（<code>add&lt;int&gt;(1.2, 3.4)</code>，强制转换为<code>int</code>）；</p>
</li>
<li><p>模板重载：多个模板函数可根据签名差异重载（如<code>template&lt;typename T&gt; T add(T a, T b)</code>和<code>template&lt;typename T&gt; T add(T a, T b, T c)</code>）。</p>
</li>
</ul>
</li>
<li><p><strong>类模板</strong>：</p>
<pre><code>template&lt;typename T, int N = 10&gt; // 支持默认模板参数class Array &#123;private:    T data[N];public:    T&amp; operator[](int idx) &#123; return data[idx]; &#125;&#125;;
</code></pre>
<ul>
<li>实例化时必须指定模板参数（<code>Array&lt;int, 20&gt; arr;</code>或<code>Array&lt;double&gt; arr;</code>，使用默认参数<code>N=10</code>）。</li>
</ul>
</li>
</ul>
<h4 id="2-模板特化与偏特化"><a href="#2-模板特化与偏特化" class="headerlink" title="2. 模板特化与偏特化"></a>2. 模板特化与偏特化</h4><ul>
<li><p><strong>全特化</strong>：针对特定类型完全定制实现（覆盖通用模板）：</p>
<pre><code>template&lt;&gt; // 全特化，无模板参数class Array&lt;char, 10&gt; &#123;    // 针对char类型、N=10的定制实现&#125;;
</code></pre>
</li>
<li><p><strong>偏特化</strong>：部分指定模板参数（仅类模板支持，函数模板不支持）：</p>
<pre><code>template&lt;typename T&gt; // 偏特化N=5class Array&lt;T, 5&gt; &#123; /* 定制实现 */ &#125;;template&lt;typename T&gt; // 偏特化T为指针类型class Array&lt;T*, 10&gt; &#123; /* 定制实现 */ &#125;;
</code></pre>
</li>
</ul>
<h4 id="3-万能引用与完美转发"><a href="#3-万能引用与完美转发" class="headerlink" title="3. 万能引用与完美转发"></a>3. 万能引用与完美转发</h4><ul>
<li><p><strong>万能引用（T&amp;&amp;）</strong>：仅在模板参数推导时生效（<code>template&lt;typename T&gt; void f(T&amp;&amp; t)</code>），可接收左值和右值：</p>
<ul>
<li><p>实参为左值（<code>int x; f(x)</code>）→<code>T</code>推导为<code>int&amp;</code>，<code>T&amp;&amp;</code>折叠为<code>int&amp;</code>（左值引用）；</p>
</li>
<li><p>实参为右值（<code>f(10)</code>）→<code>T</code>推导为<code>int</code>，<code>T&amp;&amp;</code>为<code>int&amp;&amp;</code>（右值引用）。</p>
</li>
</ul>
</li>
<li><p><strong>完美转发（std::forward）</strong>：配合万能引用，保留实参的左&#x2F;右值属性，避免类型退化：</p>
<pre><code>template&lt;typename T&gt;void wrapper(T&amp;&amp; t) &#123;    func(std::forward&lt;T&gt;(t)); // 若t是右值，转发为右值；若为左值，转发为左值&#125;
</code></pre>
</li>
</ul>
<h4 id="4-SFINAE（替换失败不是错误）"><a href="#4-SFINAE（替换失败不是错误）" class="headerlink" title="4. SFINAE（替换失败不是错误）"></a>4. SFINAE（替换失败不是错误）</h4><ul>
<li><p>核心：模板实例化时，若替换模板参数导致编译错误，编译器会忽略该实例，尝试其他匹配（而非直接报错）；</p>
</li>
<li><p>应用场景：类型萃取（判断类型是否为指针&#x2F;数组&#x2F;类）、条件编译：</p>
<pre><code>// 判断T是否为指针类型template&lt;typename T, typename = std::enable_if_t&lt;std::is_pointer_v&lt;T&gt;&gt;&gt;void print(T ptr) &#123; std::cout &lt;&lt; *ptr &lt;&lt; std::endl; &#125;int x = 10;print(&amp;x); // 匹配成功（T=int*，is_pointer_v为true）print(x);  // 替换失败，编译器忽略该实例，无匹配函数（不会报错）
</code></pre>
</li>
</ul>
<h3 id="五、C-11-核心新特性（面试高频）"><a href="#五、C-11-核心新特性（面试高频）" class="headerlink" title="五、C++11+核心新特性（面试高频）"></a>五、C++11+核心新特性（面试高频）</h3><h4 id="1-右值引用与移动语义"><a href="#1-右值引用与移动语义" class="headerlink" title="1. 右值引用与移动语义"></a>1. 右值引用与移动语义</h4><ul>
<li><p><strong>左值与右值</strong>：</p>
<ul>
<li><p>左值：可取地址、有名字（如变量<code>x</code>、<code>arr[0]</code>）；</p>
</li>
<li><p>右值：不可取地址、无名字（如字面量<code>10</code>、临时对象<code>A()</code>、<code>std::move(x)</code>）。</p>
</li>
</ul>
</li>
<li><p><strong>右值引用（T&amp;&amp;）</strong>：专门绑定右值，延长临时对象的生命周期（避免被立即销毁）。</p>
</li>
<li><p><strong>移动语义</strong>：通过<code>std::move</code>将左值转为右值，转移资源所有权（无内存拷贝，仅修改指针指向）：</p>
<pre><code>std::vector&lt;int&gt; v1&#123;1,2,3&#125;;std::vector&lt;int&gt; v2 = std::move(v1); // 移动v1的资源到v2，v1变为空（安全状态）
</code></pre>
</li>
<li><p>注意：<code>std::move</code>仅做类型转换，不改变对象生命周期，不能对已销毁的对象操作。</p>
</li>
</ul>
<h4 id="2-智能指针（内存管理核心）"><a href="#2-智能指针（内存管理核心）" class="headerlink" title="2. 智能指针（内存管理核心）"></a>2. 智能指针（内存管理核心）</h4><ul>
<li><p><strong>核心目的</strong>：自动管理堆内存，避免内存泄漏（RAII思想：资源获取即初始化）。</p>
</li>
<li><p><strong>unique_ptr</strong>：</p>
<ul>
<li><p>独占所有权（同一时间仅一个<code>unique_ptr</code>指向对象），不可拷贝（拷贝构造、拷贝赋值被<code>delete</code>），可移动；</p>
</li>
<li><p>用法：<code>std::unique_ptr&lt;int&gt; p = std::make_unique&lt;int&gt;(10);</code>（<code>make_unique</code>比<code>new</code>更安全，避免内存泄漏）；</p>
</li>
<li><p>优势：轻量级（无引用计数开销），支持数组（<code>std::unique_ptr&lt;int[]&gt;</code>）。</p>
</li>
</ul>
</li>
<li><p><strong>shared_ptr</strong>：</p>
<ul>
<li><p>共享所有权（多个<code>shared_ptr</code>指向同一对象，通过引用计数管理生命周期）；</p>
</li>
<li><p>引用计数：线程安全（原子操作），但对象的访问不是线程安全的；</p>
</li>
<li><p>用法：<code>std::shared_ptr&lt;int&gt; p = std::make_shared&lt;int&gt;(10);</code>（<code>make_shared</code>比<code>new</code>更高效，一次性分配对象和引用计数内存）；</p>
</li>
<li><p>风险：循环引用（如<code>A</code>含<code>shared_ptr&lt;B&gt;</code>，<code>B</code>含<code>shared_ptr&lt;A&gt;</code>），导致引用计数无法归零，内存泄漏；解决方案：<code>weak_ptr</code>。</p>
</li>
</ul>
</li>
<li><p><strong>weak_ptr</strong>：</p>
<ul>
<li><p>弱引用，不影响引用计数，不能直接访问对象（需通过<code>lock()</code>获取<code>shared_ptr</code>）；</p>
</li>
<li><p>核心用途：解决<code>shared_ptr</code>的循环引用，观察对象是否存活（<code>expired()</code>判断）。</p>
</li>
</ul>
</li>
<li><p><strong>auto_ptr</strong>：C++11前的智能指针，已被废弃（拷贝时转移所有权，易引发悬空指针）。</p>
</li>
</ul>
<h4 id="3-初始化与类型推导"><a href="#3-初始化与类型推导" class="headerlink" title="3. 初始化与类型推导"></a>3. 初始化与类型推导</h4><ul>
<li><p><strong>统一初始化（{}）</strong>：支持所有类型初始化，避免窄化转换（如<code>int a&#123;3.14&#125;</code>编译报错）：</p>
<pre><code>int x&#123;5&#125;;std::vector&lt;int&gt; v&#123;1,2,3&#125;;struct A &#123; int a; int b; &#125;; A a&#123;1,2&#125;;
</code></pre>
</li>
<li><p><strong>列表初始化（std::initializer_list）</strong>：支持变长参数初始化，常用于容器、函数参数：</p>
<pre><code>std::vector&lt;int&gt; v(std::initializer_list&lt;int&gt;&#123;1,2,3&#125;);void sum(std::initializer_list&lt;int&gt; nums) &#123; /* 遍历nums求和 */ &#125;
</code></pre>
</li>
<li><p><strong>类型推导</strong>：</p>
<ul>
<li><p><code>auto</code>：根据初始化表达式推导类型，必须初始化（<code>auto x;</code>非法），不保留<code>const/volatile</code>和引用属性（需显式添加：<code>const auto&amp; x = y;</code>）；</p>
</li>
<li><p><code>decltype</code>：推导表达式的类型（包括<code>const/volatile</code>、引用、右值属性）：</p>
<pre><code>int x = 10;decltype(x) y = 20; // y=intdecltype(x+) z = 30; // x+是右值，z=intdecltype((x)) r = x; // (x)是左值引用，r=int&amp;
</code></pre>
</li>
<li><p><code>decltype(auto)</code>：保留表达式的值类别，用于函数返回值（避免手动推导错误）：</p>
<pre><code>decltype(auto) f() &#123;    int x = 10;    return (x); // 返回int&amp;（左值引用）&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="4-Lambda表达式（匿名函数）"><a href="#4-Lambda表达式（匿名函数）" class="headerlink" title="4. Lambda表达式（匿名函数）"></a>4. Lambda表达式（匿名函数）</h4><ul>
<li><p>格式：<code>[捕获列表](参数列表) mutable noexcept -&gt; 返回值类型 &#123; 函数体 &#125;</code></p>
<ul>
<li><p>捕获列表：控制外部变量的访问方式：</p>
<ul>
<li><p><code>[]</code>：无捕获；</p>
</li>
<li><p><code>[=]</code>：值捕获（拷贝外部变量，只读，加<code>mutable</code>可修改拷贝）；</p>
</li>
<li><p><code>[&amp;]</code>：引用捕获（直接访问外部变量，可修改）；</p>
</li>
<li><p><code>[this]</code>：捕获当前对象（类成员函数中使用，可访问成员变量&#x2F;函数）；</p>
</li>
<li><p><code>[x, &amp;y]</code>：混合捕获（x值捕获，y引用捕获）；</p>
</li>
</ul>
</li>
<li><p>省略规则：参数列表为空可省略<code>()</code>；返回值可由编译器推导（单return语句），可省略<code>-&gt; 返回值类型</code>；</p>
</li>
<li><p>用法：作为函数参数（如STL算法、线程函数）、局部函数：</p>
<pre><code>std::vector&lt;int&gt; v&#123;3,1,2&#125;;std::sort(v.begin(), v.end(), [](int a, int b) &#123; return a &lt; b; &#125;); // 升序排序
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="5-其他常用新特性"><a href="#5-其他常用新特性" class="headerlink" title="5. 其他常用新特性"></a>5. 其他常用新特性</h4><ul>
<li><p><strong>范围for循环</strong>：遍历容器&#x2F;数组，简洁高效：</p>
<pre><code>std::vector&lt;int&gt; v&#123;1,2,3&#125;;for (int x : v) std::cout &lt;&lt; x; // 遍历拷贝for (int&amp; x : v) x *= 2; // 遍历修改
</code></pre>
</li>
<li><p><strong>nullptr</strong>：空指针常量，类型安全（避免<code>NULL</code>（本质是<code>0</code>）的类型歧义）：</p>
<pre><code>void f(int x) &#123;&#125;void f(void* p) &#123;&#125;f(NULL); // 调用f(int)（歧义）f(nullptr); // 调用f(void*)（正确）
</code></pre>
</li>
<li><p><strong>noexcept</strong>：告知编译器函数不抛异常，用于移动构造&#x2F;赋值、析构函数（编译器优化性能）：</p>
<pre><code>A(A&amp;&amp; other) noexcept &#123; /* 移动资源 */ &#125;
</code></pre>
</li>
<li><p><strong>constexpr扩展（C++14&#x2F;17）</strong>：<code>constexpr</code>函数支持循环、条件判断，可用于更复杂的编译期计算；<code>constexpr if</code>（C++17）：编译期条件分支（无运行时开销）。</p>
</li>
</ul>
<h3 id="六、内存管理（面试核心难点）"><a href="#六、内存管理（面试核心难点）" class="headerlink" title="六、内存管理（面试核心难点）"></a>六、内存管理（面试核心难点）</h3><h4 id="1-内存分配与释放"><a href="#1-内存分配与释放" class="headerlink" title="1. 内存分配与释放"></a>1. 内存分配与释放</h4><ul>
<li><p><strong>new&#x2F;delete vs malloc&#x2F;free</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>特性</td>
<td>new&#x2F;delete</td>
<td>malloc&#x2F;free</td>
</tr>
<tr>
<td>类型安全</td>
<td>是（分配时指定类型）</td>
<td>否（返回void*，需强转）</td>
</tr>
<tr>
<td>调用构造&#x2F;析构</td>
<td>是（new调用构造，delete调用析构）</td>
<td>否（仅分配&#x2F;释放内存）</td>
</tr>
<tr>
<td>内存大小</td>
<td>自动计算（<code>new int[10]</code>）</td>
<td>需手动指定（<code>malloc(40)</code>）</td>
</tr>
<tr>
<td>异常处理</td>
<td>失败抛出<code>std::bad_alloc</code></td>
<td>失败返回NULL</td>
</tr>
<tr>
<td>重载</td>
<td>可重载<code>operator new/delete</code></td>
<td>不可重载</td>
</tr>
</tbody></table>
</li>
<li><p><strong>placement new</strong>：在指定内存位置构造对象</p>
</li>
<li><p><strong>数组分配与释放</strong>：<code>new int[10]</code>→<code>delete[]</code>（必须匹配，否则仅析构第一个元素，导致内存泄漏）。</p>
</li>
<li><p><strong>内存泄漏</strong>：</p>
<ul>
<li><p>定义：堆内存分配后未释放，且无法访问（如丢失指针）；</p>
</li>
<li><p>排查工具：Valgrind、Visual Studio Memory Profiler；</p>
</li>
<li><p>避免方法：使用智能指针、RAII封装资源（如<code>std::lock_guard</code>管理锁）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-内存对齐"><a href="#2-内存对齐" class="headerlink" title="2. 内存对齐"></a>2. 内存对齐</h4><ul>
<li><p><strong>定义</strong>：编译器强制要求数据的起始地址是「对齐系数」的整数倍（避免非对齐访问）。</p>
</li>
<li><p><strong>核心原因</strong>：</p>
<ul>
<li><p>提升CPU访问效率：CPU以「Cache Line（通常64字节）」为单位读取内存，非对齐数据需2次读取；</p>
</li>
<li><p>兼容硬件限制：部分硬件（如ARM）不支持非对齐访问，会触发硬件异常。</p>
</li>
</ul>
</li>
<li><p><strong>具体规则</strong>：</p>
<ul>
<li><p>基本类型对齐系数 &#x3D; 自身大小（<code>char=1</code>、<code>int=4</code>、<code>double=8</code>）；</p>
</li>
<li><p>结构体&#x2F;类对齐系数 &#x3D; 所有成员对齐系数的最大值；</p>
</li>
<li><p>结构体总大小 &#x3D; 对齐系数的整数倍（不足时填充字节）；</p>
</li>
<li><p>成员按声明顺序排列，每个成员的起始地址是其自身对齐系数的整数倍。</p>
</li>
</ul>
</li>
<li><p><strong>手动控制对齐</strong>：C++11+<code>alignas</code>（指定对齐系数）、<code>alignof</code>（获取对齐系数）：</p>
<pre><code>struct alignas(16) Data &#123; // 强制对齐到16字节    int a; // 4字节    double b; // 8字节（起始地址8，对齐8）&#125;; // 总大小16（16是16的整数倍）
</code></pre>
</li>
</ul>
<h4 id="3-伪共享（False-Sharing）"><a href="#3-伪共享（False-Sharing）" class="headerlink" title="3. 伪共享（False Sharing）"></a>3. 伪共享（False Sharing）</h4><ul>
<li><p><strong>定义</strong>：多个线程访问不同数据，但数据位于同一CPU Cache Line，导致Cache Line频繁失效（Invalidate），引发性能损耗。</p>
</li>
<li><p><strong>避免方法</strong>：</p>
<ul>
<li><p>Cache Line填充：添加无用字节，让目标数据独占一个Cache Line（64字节）：</p>
<pre><code>struct alignas(64) Counter &#123;    int value;    char padding[60]; // 填充60字节，确保value独占64字节Cache Line&#125;;
</code></pre>
</li>
<li><p>使用<code>alignas</code>强制对齐：<code>alignas(64) int x;</code>；</p>
</li>
<li><p>调整数据访问顺序：让不同线程访问的数据集分布在不同Cache Line（如矩阵按行优先访问）。</p>
</li>
</ul>
</li>
</ul>
<h3 id="七、并发与多线程（底层开发高频）"><a href="#七、并发与多线程（底层开发高频）" class="headerlink" title="七、并发与多线程（底层开发高频）"></a>七、并发与多线程（底层开发高频）</h3><h4 id="1-线程基础"><a href="#1-线程基础" class="headerlink" title="1. 线程基础"></a>1. 线程基础</h4><ul>
<li><p><strong>线程创建（C++11+ std::thread）</strong>：</p>
<pre><code>void func(int x) &#123; /* 线程函数 */ &#125;std::thread t1(func, 10); // 传入函数和参数std::thread t2([]&#123; /* lambda作为线程函数 */ &#125;);t1.join(); // 等待线程结束，回收资源t2.detach(); // 线程后台运行，不等待（需确保线程函数生命周期）
</code></pre>
</li>
<li><p><strong>线程属性</strong>：通过<code>std::thread::native_handle()</code>获取原生线程句柄（如pthread_t），设置栈大小、优先级等。</p>
</li>
<li><p><strong>线程局部存储（thread_local）</strong>：变量在每个线程中有独立副本，生命周期与线程一致：</p>
<pre><code>thread_local int x = 0; // 每个线程的x互不干扰
</code></pre>
</li>
</ul>
<h4 id="2-线程同步机制"><a href="#2-线程同步机制" class="headerlink" title="2. 线程同步机制"></a>2. 线程同步机制</h4><ul>
<li><p><strong>互斥锁（std::mutex）</strong>：</p>
<ul>
<li><p>独占锁，同一时间仅一个线程获取锁，用于保护共享资源；</p>
</li>
<li><p>常用封装：<code>std::lock_guard</code>（RAII，构造时加锁，析构时解锁）、<code>std::unique_lock</code>（更灵活，支持延迟加锁、尝试加锁）：</p>
<pre><code>std::mutex mtx;int shared_data = 0;void func() &#123;    std::lock_guard&lt;std::mutex&gt; lock(mtx); // 自动加锁/解锁    shared_data++;&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>读写锁（std::shared_mutex，C++17+）</strong>：</p>
<ul>
<li><p>多读者（共享锁）、单写者（排他锁），读-读不互斥，读-写&#x2F;写-写互斥；</p>
</li>
<li><p>适用场景：读多写少（如缓存查询、配置读取）：</p>
<pre><code>std::shared_mutex rw_mtx;void read() &#123;    std::shared_lock&lt;std::shared_mutex&gt; lock(rw_mtx); // 共享锁    // 读取共享资源&#125;void write() &#123;    std::unique_lock&lt;std::shared_mutex&gt; lock(rw_mtx); // 排他锁    // 修改共享资源&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>自旋锁（std::spinlock，C++20+）</strong>：</p>
<ul>
<li>线程获取锁失败时不阻塞，循环重试（自旋），适用于锁持有时间极短、CPU核心充足的场景（避免线程切换开销）。</li>
</ul>
</li>
<li><p><strong>条件变量（std::condition_variable）</strong>：</p>
<ul>
<li><p>配合<code>std::mutex</code>实现线程等待&#x2F;唤醒，用于线程间通信（如生产者-消费者模型）：</p>
<pre><code>std::mutex mtx;std::condition_variable cv;bool ready = false;void consumer() &#123;    std::unique_lock&lt;std::mutex&gt; lock(mtx);    cv.wait(lock, []&#123; return ready; &#125;); // 等待ready为true（避免虚假唤醒）    // 消费数据&#125;void producer() &#123;    &#123;        std::lock_guard&lt;std::mutex&gt; lock(mtx);        ready = true;    &#125;    cv.notify_one(); // 唤醒一个等待线程&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>信号量（std::counting_semaphore，C++20+）</strong>：</p>
<ul>
<li><p>计数器控制并发访问次数，适用于限制资源访问（如线程池最大并发数）：</p>
<pre><code>std::counting_semaphore&lt;5&gt; sem(5); // 最大并发5个线程void func() &#123;    sem.acquire(); // 计数器减1，为0则阻塞    // 访问资源    sem.release(); // 计数器加1&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-原子操作与内存序"><a href="#3-原子操作与内存序" class="headerlink" title="3. 原子操作与内存序"></a>3. 原子操作与内存序</h4><ul>
<li><p><strong>原子变量（std::atomic）</strong>：</p>
<ul>
<li><p>支持原子读写、自增、比较交换（CAS）等操作，无需手动加锁，底层依赖硬件原子指令（如x86 LOCK前缀）；</p>
</li>
<li><p>支持类型：基本类型（<code>bool</code>、<code>int</code>、<code>long long</code>）、指针类型、可平凡复制的自定义类型（需硬件支持）；</p>
</li>
<li><p>常用操作：<code>load()</code>（读）、<code>store()</code>（写）、<code>fetch_add()</code>（原子自增）、<code>compare_exchange_weak()</code>（弱CAS）。</p>
</li>
</ul>
</li>
<li><p><strong>内存序（memory order）</strong>：</p>
<ul>
<li><p>核心目的：禁止编译器和CPU的指令重排，确保多线程间的数据可见性；</p>
</li>
<li><p>常用内存序：</p>
<ul>
<li><p><code>std::memory_order_seq_cst</code>（默认）：最严格，全局顺序一致，性能开销最大；</p>
</li>
<li><p><code>std::memory_order_acquire</code>（读操作）：读之后的指令不能重排到读之前，确保读操作后能看到之前的所有写操作；</p>
</li>
<li><p><code>std::memory_order_release</code>（写操作）：写之前的指令不能重排到写之后，确保写操作前的所有修改都可见；</p>
</li>
</ul>
</li>
<li><p>经典场景（生产者-消费者）：</p>
<pre><code>std::atomic&lt;bool&gt; ready(false);int data;void producer() &#123;    data = 10; // 写数据    ready.store(true, std::memory_order_release); // 释放语义&#125;void consumer() &#123;    while (!ready.load(std::memory_order_acquire)); // 获取语义    assert(data == 10); // 必然成立&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="4-死锁与避免"><a href="#4-死锁与避免" class="headerlink" title="4. 死锁与避免"></a>4. 死锁与避免</h4><ul>
<li><p><strong>死锁四个必要条件</strong>：互斥（资源独占）、持有并等待（持有资源同时申请其他资源）、不可剥夺（资源不能被强制回收）、循环等待（线程间形成资源依赖环）；</p>
</li>
<li><p><strong>避免方法</strong>：</p>
<ul>
<li><p>破坏循环等待：按固定顺序申请资源（如先申请锁A，再申请锁B）；</p>
</li>
<li><p>破坏持有并等待：一次性申请所有资源；</p>
</li>
<li><p>超时重试：使用<code>std::unique_lock::try_lock_for()</code>，超时后释放已申请资源；</p>
</li>
<li><p>使用<code>std::lock()</code>：同时申请多个锁，避免部分申请成功导致死锁。</p>
</li>
</ul>
</li>
</ul>
<h3 id="八、STL核心（面试高频）"><a href="#八、STL核心（面试高频）" class="headerlink" title="八、STL核心（面试高频）"></a>八、STL核心（面试高频）</h3><h4 id="1-STL六大组件"><a href="#1-STL六大组件" class="headerlink" title="1. STL六大组件"></a>1. STL六大组件</h4><p>容器（Container）、算法（Algorithm）、迭代器（Iterator）、配接器（Adapter）、函数对象（Functor）、分配器（Allocator）。</p>
<h4 id="2-容器分类与底层实现"><a href="#2-容器分类与底层实现" class="headerlink" title="2. 容器分类与底层实现"></a>2. 容器分类与底层实现</h4><h4 id="（1）序列容器（有序，按插入顺序存储）"><a href="#（1）序列容器（有序，按插入顺序存储）" class="headerlink" title="（1）序列容器（有序，按插入顺序存储）"></a>（1）序列容器（有序，按插入顺序存储）</h4><ul>
<li><p><strong>vector</strong>：</p>
<ul>
<li><p>底层：动态数组，连续内存；</p>
</li>
<li><p>特性：随机访问高效（O(1)），尾部插入&#x2F;删除高效（O(1)），中间插入&#x2F;删除低效（O(n)，需移动元素）；</p>
</li>
<li><p>扩容机制：通常扩容为原容量的2倍（或1.5倍），重新分配内存+拷贝元素，<code>reserve(n)</code>预分配容量（避免频繁扩容），<code>resize(n)</code>调整元素个数（不足补默认值，超出截断）。</p>
</li>
</ul>
</li>
<li><p><strong>list</strong>：</p>
<ul>
<li><p>底层：双向链表，离散内存；</p>
</li>
<li><p>特性：中间&#x2F;两端插入&#x2F;删除高效（O(1)），随机访问低效（O(n)），不支持随机访问迭代器（仅支持双向迭代器）。</p>
</li>
</ul>
</li>
<li><p><strong>deque</strong>：</p>
<ul>
<li><p>底层：分段连续数组（中央控制器管理多个缓冲区）；</p>
</li>
<li><p>特性：两端插入&#x2F;删除高效（O(1)），随机访问较高效（O(1)），支持扩容不移动所有元素（仅新增缓冲区）。</p>
</li>
</ul>
</li>
<li><p><strong>array（C++11+）</strong>：</p>
<ul>
<li><p>底层：固定大小数组，连续内存；</p>
</li>
<li><p>特性：栈上分配（空间高效），随机访问O(1)，大小固定（编译期确定），无扩容。</p>
</li>
</ul>
</li>
</ul>
<h4 id="（2）关联容器（有序，自动排序）"><a href="#（2）关联容器（有序，自动排序）" class="headerlink" title="（2）关联容器（有序，自动排序）"></a>（2）关联容器（有序，自动排序）</h4><ul>
<li><p><strong>set&#x2F;multiset</strong>：</p>
<ul>
<li><p>底层：红黑树（平衡二叉搜索树）；</p>
</li>
<li><p>特性：有序（默认升序），插入&#x2F;删除&#x2F;查找高效（O(logn)），<code>set</code>不允许重复元素，<code>multiset</code>允许重复。</p>
</li>
</ul>
</li>
<li><p><strong>map&#x2F;multimap</strong>：</p>
<ul>
<li><p>底层：红黑树；</p>
</li>
<li><p>特性：键值对存储，键有序且唯一（<code>map</code>）&#x2F;可重复（<code>multimap</code>），通过键查找O(logn)，支持<code>[]</code>访问（<code>map[key]</code>，不存在则插入默认值）。</p>
</li>
</ul>
</li>
</ul>
<h4 id="（3）无序关联容器（C-11-，无序，哈希存储）"><a href="#（3）无序关联容器（C-11-，无序，哈希存储）" class="headerlink" title="（3）无序关联容器（C++11+，无序，哈希存储）"></a>（3）无序关联容器（C++11+，无序，哈希存储）</h4><ul>
<li><p><strong>unordered_set&#x2F;unordered_multiset</strong>：</p>
<ul>
<li><p>底层：哈希表（链地址法解决冲突）；</p>
</li>
<li><p>特性：无序，插入&#x2F;删除&#x2F;查找平均O(1)，最坏O(n)（哈希冲突严重），不支持排序。</p>
</li>
</ul>
</li>
<li><p><strong>unordered_map&#x2F;unordered_multimap</strong>：</p>
<ul>
<li><p>底层：哈希表；</p>
</li>
<li><p>特性：键值对存储，键无序且唯一（<code>unordered_map</code>）&#x2F;可重复（<code>unordered_multimap</code>），<code>[]</code>访问高效，不支持排序。</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3. 迭代器"></a>3. 迭代器</h4><ul>
<li><p><strong>迭代器类型</strong>：输入迭代器（只读，单向）、输出迭代器（只写，单向）、前向迭代器（读写，单向）、双向迭代器（读写，双向）、随机访问迭代器（读写，随机访问，支持<code>+/-</code>、<code>[]</code>）；</p>
</li>
<li><p><strong>容器迭代器支持</strong>：</p>
<ul>
<li><p>随机访问：<code>vector</code>、<code>deque</code>、<code>array</code>；</p>
</li>
<li><p>双向：<code>list</code>、<code>set/map</code>；</p>
</li>
<li><p>前向：<code>unordered_set/unordered_map</code>；</p>
</li>
</ul>
</li>
<li><p><strong>迭代器失效</strong>（面试高频）：</p>
<ul>
<li><p><code>vector</code>：扩容后迭代器失效（内存地址变化），中间插入&#x2F;删除后，后续迭代器失效；</p>
</li>
<li><p><code>list</code>：插入&#x2F;删除仅当前迭代器失效，其他迭代器有效；</p>
</li>
<li><p><code>unordered_map</code>：扩容后迭代器失效（哈希表重组），插入&#x2F;删除仅当前元素迭代器失效。</p>
</li>
</ul>
</li>
</ul>
<h4 id="4-常用算法"><a href="#4-常用算法" class="headerlink" title="4. 常用算法"></a>4. 常用算法</h4><ul>
<li><p><strong>排序算法</strong>：<code>std::sort</code>（快速排序，平均O(nlogn)）、<code>std::stable_sort</code>（稳定排序）；</p>
</li>
<li><p><strong>查找算法</strong>：<code>std::find</code>（线性查找O(n)）、<code>std::binary_search</code>（二分查找O(logn)，需先排序）；</p>
</li>
<li><p><strong>修改算法</strong>：<code>std::transform</code>（元素转换）、<code>std::replace</code>（替换元素）、<code>std::remove</code>（移除元素，需配合<code>erase</code>删除）；</p>
</li>
<li><p><strong>遍历算法</strong>：<code>std::for_each</code>（遍历元素，可传入lambda）；</p>
</li>
<li><p><strong>数值算法</strong>：<code>std::accumulate</code>（累加求和）、<code>std::min_element</code>（找最小值）。</p>
</li>
</ul>
<h3 id="九、优化"><a href="#九、优化" class="headerlink" title="九、优化"></a>九、优化</h3><ol>
<li><h4 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h4></li>
</ol>
<ul>
<li><p>内联函数</p>
</li>
<li><p>返回值优化（RVO&#x2F;NRVO）</p>
</li>
<li><p>循环优化</p>
</li>
</ul>
<ol start="2">
<li><h4 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h4></li>
</ol>
<ul>
<li><p>对象池模式</p>
</li>
<li><p>小对象分配器</p>
</li>
<li><p>缓存友好代码：</p>
<ul>
<li><p>数据局部性原理</p>
</li>
<li><p>伪共享（False Sharing）及避免方法</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><h4 id="运行时优化"><a href="#运行时优化" class="headerlink" title="运行时优化"></a>运行时优化</h4></li>
</ol>
<ul>
<li><p>虚函数调用开销</p>
</li>
<li><p>异常处理开销</p>
</li>
<li><p>动态类型识别（RTTI）开销</p>
</li>
</ul>
<h3 id="十、设计模式与最佳实践"><a href="#十、设计模式与最佳实践" class="headerlink" title="十、设计模式与最佳实践"></a>十、设计模式与最佳实践</h3><ol>
<li><h4 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h4></li>
</ol>
<ul>
<li><p>单例模式：线程安全实现（Meyers’ Singleton）</p>
</li>
<li><p>工厂模式</p>
</li>
<li><p>观察者模式</p>
</li>
<li><p>RAII（Resource Acquisition Is Initialization）</p>
</li>
<li><p>PIMPL（Pointer to Implementation）</p>
</li>
</ul>
<ol start="2">
<li><h4 id="C-惯用法"><a href="#C-惯用法" class="headerlink" title="C++ 惯用法"></a>C++ 惯用法</h4></li>
</ol>
<ul>
<li><p>CRTP（奇异递归模板模式）</p>
</li>
<li><p>类型擦除</p>
</li>
<li><p>表达式模板</p>
</li>
<li><p>标签分发（Tag Dispatching）</p>
</li>
</ul>
<h3 id="十一、系统级编程"><a href="#十一、系统级编程" class="headerlink" title="十一、系统级编程"></a>十一、系统级编程</h3><ol>
<li><h4 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h4></li>
</ol>
<ul>
<li><p>编译过程：预处理、编译、汇编、链接</p>
</li>
<li><p>符号解析与重定位</p>
</li>
<li><p>静态库与动态库：</p>
<ul>
<li><p>创建与使用</p>
</li>
<li><p>符号可见性</p>
</li>
<li><p>动态加载（<code>dlopen</code>, <code>dlsym</code>）</p>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><h4 id="二进制格式"><a href="#二进制格式" class="headerlink" title="二进制格式"></a>二进制格式</h4></li>
</ol>
<ul>
<li><p>ELF 文件格式：段（Segment）与节（Section）</p>
</li>
<li><p>名称修饰（Name Mangling）</p>
</li>
<li><p>调试信息</p>
</li>
</ul>
<ol start="3">
<li><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4></li>
</ol>
<ul>
<li><p>文件 I&#x2F;O 操作</p>
</li>
<li><p>进程间通信（IPC）：</p>
<ul>
<li><p>管道、消息队列、共享内存</p>
</li>
<li><p>信号量</p>
</li>
</ul>
</li>
</ul>
<h3 id="十二、调试与工具"><a href="#十二、调试与工具" class="headerlink" title="十二、调试与工具"></a>十二、调试与工具</h3><ol>
<li><h4 id="调试技术"><a href="#调试技术" class="headerlink" title="调试技术"></a>调试技术</h4></li>
</ol>
<ul>
<li><p>核心转储分析</p>
</li>
<li><p>内存调试工具：Valgrind, AddressSanitizer</p>
</li>
<li><p>性能分析工具：gprof, perf, VTune</p>
</li>
</ul>
<ol start="2">
<li><h4 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h4></li>
</ol>
<ul>
<li><p>CMake：现代构建系统</p>
</li>
<li><p>编译器特定特性：GCC&#x2F;Clang&#x2F;MSVC 差异</p>
</li>
</ul>
<h3 id="十三、跨平台开发"><a href="#十三、跨平台开发" class="headerlink" title="十三、跨平台开发"></a>十三、跨平台开发</h3><ol>
<li><h4 id="平台差异处理"><a href="#平台差异处理" class="headerlink" title="平台差异处理"></a>平台差异处理</h4></li>
</ol>
<ul>
<li><p>字节序（Endianness）</p>
</li>
<li><p>数据对齐</p>
</li>
<li><p>系统 API 抽象</p>
</li>
</ul>
<ol start="2">
<li><h4 id="可移植性最佳实践"><a href="#可移植性最佳实践" class="headerlink" title="可移植性最佳实践"></a>可移植性最佳实践</h4></li>
</ol>
<ul>
<li><p>标准符合性</p>
</li>
<li><p>特性检测</p>
</li>
<li><p>条件编译</p>
</li>
</ul>
<h3 id="十四、常见面试易错点与优化"><a href="#十四、常见面试易错点与优化" class="headerlink" title="十四、常见面试易错点与优化"></a>十四、常见面试易错点与优化</h3><h4 id="1-易错点"><a href="#1-易错点" class="headerlink" title="1. 易错点"></a>1. 易错点</h4><ul>
<li><p>虚函数未加<code>virtual</code>导致多态失效；</p>
</li>
<li><p>父类析构未加<code>virtual</code>导致子类资源泄漏；</p>
</li>
<li><p><code>shared_ptr</code>循环引用导致内存泄漏；</p>
</li>
<li><p>迭代器失效（如<code>vector</code>扩容后使用旧迭代器）；</p>
</li>
<li><p>浅拷贝导致双重释放（未重写拷贝构造&#x2F;拷贝赋值）；</p>
</li>
<li><p>非对齐访问导致性能损耗或硬件异常；</p>
</li>
<li><p>内存序使用不当导致数据可见性问题；</p>
</li>
<li><p>死锁（未按顺序申请资源、未释放锁）。</p>
</li>
</ul>
<h4 id="2-性能优化"><a href="#2-性能优化" class="headerlink" title="2. 性能优化"></a>2. 性能优化</h4><ul>
<li><p><strong>容器优化</strong>：<code>vector</code>用<code>reserve</code>预分配容量，<code>list</code>避免随机访问，<code>unordered_map</code>合理设置哈希表大小（减少冲突）；</p>
</li>
<li><p><strong>内存优化</strong>：使用智能指针避免泄漏，小对象用内存池（减少<code>new/delete</code>开销），避免内存碎片；</p>
</li>
<li><p><strong>并发优化</strong>：读多写少用读写锁，锁粒度最小化（仅保护共享资源），避免锁竞争；</p>
</li>
<li><p><strong>代码优化</strong>：内联短小函数，避免冗余拷贝（用<code>std::move</code>），循环中避免创建临时对象；</p>
</li>
<li><p><strong>缓存优化</strong>：数据按Cache Line对齐，避免伪共享，连续内存访问（如<code>vector</code>比<code>list</code>缓存友好）。</p>
</li>
</ul>
<p>以上覆盖C++面试所有核心考点，从基础语法到底层原理，从特性使用到性能优化，适合系统性复习。可根据岗位需求（如底层开发侧重内存&#x2F;并发，应用开发侧重STL&#x2F;OOP）重点突破。</p>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><h3 id="1-内存对齐的具体规则是什么？"><a href="#1-内存对齐的具体规则是什么？" class="headerlink" title="1. 内存对齐的具体规则是什么？"></a><strong>1. 内存对齐的具体规则是什么？</strong></h3><ul>
<li><p><strong>参考答案</strong>：</p>
<ul>
<li><p><strong>规则</strong>：</p>
<ul>
<li><p><strong>结构体起始地址</strong>：能被其最宽成员类型的大小整除。</p>
</li>
<li><p><strong>成员偏移地址</strong>：每个成员的偏移地址必须是 <code>min(#pragma pack(n), 该成员类型大小)</code> 的整数倍。</p>
</li>
<li><p><strong>结构体总大小</strong>：必须是所有成员中最宽类型的整数倍（同样受 <code>#pragma pack(n)</code> 影响）。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<pre><code>// 假设 sizeof(int) = 4, sizeof(char) = 1, 默认 packstruct Example &#123;    char a;      // 偏移 0, 大小 1    int b;       // 偏移 4 (1 + 3填充), 大小 4    char c;      // 偏移 8, 大小 1&#125;;               // 总大小 12 (8 + 1 + 3填充)，以满足是 4 的整数倍。
</code></pre>
</li>
</ul>
</li>
</ul>
<p><strong>正确答案</strong>：（1）定义：内存对齐是编译器强制要求<strong>数据在内存中的起始地址是其“对齐系数”的整数倍</strong>的规则，避免非对齐访问。</p>
<p>（2）核心原因：</p>
<ul>
<li><p>提升CPU访问效率：CPU以“Cache Line（通常64字节）”为单位读取内存，非对齐数据可能需要2次读取；</p>
</li>
<li><p>兼容硬件限制：部分硬件（如ARM）不支持非对齐访问，会直接触发硬件异常。</p>
</li>
</ul>
<p>（3）具体规则（C++标准，编译器可配置）：</p>
<p>① 基本数据类型的对齐系数 &#x3D; 自身大小（如char对齐1字节，int对齐4字节，double对齐8字节）；</p>
<p>② 结构体&#x2F;类的对齐系数 &#x3D; 所有成员对齐系数的最大值；</p>
<p>③ 结构体总大小 &#x3D; 对齐系数的整数倍（不足时填充字节）；</p>
<p>④ 成员按声明顺序排列，每个成员的起始地址是其自身对齐系数的整数倍。</p>
<p>示例：<br>    struct Test {    char a; &#x2F;&#x2F; 地址0（对齐1）    int b;  &#x2F;&#x2F; 地址4（填充3字节，对齐4）    char c; &#x2F;&#x2F; 地址8（对齐1）}; &#x2F;&#x2F; 总大小12（对齐系数4，12是4的整数倍）</p>
<h3 id="2-C-11-中最简洁安全的单例模式实现（Meyers‘-Singleton）"><a href="#2-C-11-中最简洁安全的单例模式实现（Meyers‘-Singleton）" class="headerlink" title="2. C++11 中最简洁安全的单例模式实现（Meyers‘ Singleton）"></a><strong>2. C++11 中最简洁安全的单例模式实现（Meyers‘ Singleton）</strong></h3><ul>
<li><p><strong>参考答案</strong>：</p>
<ul>
<li><p><strong>关键点</strong>：利用<strong>局部静态变量</strong>的线程安全初始化特性（C++11标准保证）。</p>
</li>
<li><p><strong>实现</strong>：</p>
<pre><code>class Singleton &#123;public:    // 1. 删除拷贝构造函数和赋值操作符    Singleton(const Singleton&amp;) = delete;    Singleton&amp; operator=(const Singleton&amp;) = delete;    // 2. 提供全局访问点    static Singleton&amp; getInstance() &#123;        static Singleton instance; // C++11保证此初始化是线程安全的        return instance;    &#125;private:    // 3. 将构造函数私有化，禁止外部创建实例    Singleton() = default;&#125;;
</code></pre>
</li>
<li><p><strong>为什么这是最好的？</strong>：线程安全、懒加载、代码简洁。<strong>防止外部实例化的最关键手段就是将构造函数私有化</strong>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-互斥锁（mutex）在竞争失败时，线程会做什么？"><a href="#3-互斥锁（mutex）在竞争失败时，线程会做什么？" class="headerlink" title="3. 互斥锁（mutex）在竞争失败时，线程会做什么？"></a><strong>3. 互斥锁（mutex）在竞争失败时，线程会做什么？</strong></h3><ul>
<li><p><strong>参考答案</strong>：</p>
<ul>
<li><p><strong>现代操作系统的mutex通常是混合型（Hybrid Mutex）</strong>：</p>
<ul>
<li><p><strong>首先会进行一段很短时间的自旋（Spin）</strong>，期望能很快获取锁，避免上下文切换的开销。</p>
</li>
<li><p>如果自旋后仍未获取锁，<strong>线程会进入睡眠（Sleep）状态</strong>，让出CPU给其他线程。</p>
</li>
<li><p>当锁被释放时，操作系统会唤醒其中一个睡眠的线程。</p>
</li>
</ul>
</li>
<li><p><strong>底层机制</strong>：在Linux中，<code>pthread_mutex</code> 通常基于 <strong>Futex（Fast Userspace muTEX）</strong> 实现。Futex在用户空间进行简单的原子操作尝试，如果失败则通过系统调用陷入内核，让内核来管理线程的睡眠和唤醒。<strong>单纯的“自旋”只适用于临界区极短的场景，否则会浪费大量CPU资源。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-mmap-能否完全绕过内核态进行IPC？"><a href="#4-mmap-能否完全绕过内核态进行IPC？" class="headerlink" title="4. mmap 能否完全绕过内核态进行IPC？"></a><strong>4.</strong> <strong><code>mmap</code></strong> <strong>能否完全绕过内核态进行IPC？</strong></h3><ul>
<li><p><strong>参考答案</strong>：</p>
<ul>
<li><p><strong><code>mmap</code></strong> 本身是系统调用，它需要内核来建立进程的虚拟地址空间与物理内存（或文件）之间的映射关系。</p>
</li>
<li><p><strong>建立映射后</strong>，进程在访问这块内存时，看似是“直接”操作，但实际上：</p>
<ul>
<li><p><strong>MMU（内存管理单元）和页表</strong>仍在工作，这些是由内核配置的。</p>
</li>
<li><p>如果访问的页面尚未加载（缺页异常），会触发<strong>缺页中断</strong>，<strong>内核的缺页中断处理程序</strong>需要介入，将数据从磁盘换入物理内存。</p>
</li>
</ul>
</li>
<li><p><strong>结论</strong>：<code>mmap</code> 可以减少一次数据从<strong>内核缓冲区到用户缓冲区</strong>的拷贝（相较于 <code>read</code>&#x2F;<code>write</code>），但<strong>无法完全绕过内核态</strong>。内核始终在背后进行内存管理、中断处理和权限检查。</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-哪些数据类型可以做原子变量？"><a href="#5-哪些数据类型可以做原子变量？" class="headerlink" title="5. 哪些数据类型可以做原子变量？"></a><strong>5. 哪些数据类型可以做原子变量？</strong></h3><ul>
<li><p><strong>参考答案</strong>：</p>
<ul>
<li><p><strong>天然原子性</strong>：在常见的CPU架构上，<strong>自然对齐的、宽度不超过CPU字长</strong>的标量类型（如 <code>int32_t</code>, <code>char</code>, <code>void*</code>）的读写操作本身是原子的。</p>
</li>
<li><p><strong>C++</strong> <strong><code>std::atomic</code></strong> 的适用范围：</p>
<ul>
<li><p><strong>所有整数类型和指针类型</strong>都可以直接用 <code>std::atomic</code> 模板。</p>
</li>
<li><p><strong>泛型类型</strong>：理论上任何 <code>T</code> 都可以，但对于自定义类型（结构体），<code>std::atomic</code> 可能使用互斥锁内部实现，从而失去无锁性能。可以通过 <code>std::atomic&lt;T&gt;::is_lock_free()</code> 成员函数来检查。</p>
</li>
</ul>
</li>
<li><p><strong>核心区别</strong>：问题在于区分“CPU指令级的原子操作”和“C++ <code>std::atomic</code> 库的支持”。<code>std::atomic</code> 库为所有类型提供了原子操作的接口，但其底层实现是否是无锁的（Lock-free），取决于CPU对该类型大小的支持。</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-无锁环形缓冲区（Ring-Buffer）与无锁队列的主要区别"><a href="#6-无锁环形缓冲区（Ring-Buffer）与无锁队列的主要区别" class="headerlink" title="6. 无锁环形缓冲区（Ring Buffer）与无锁队列的主要区别"></a><strong>6. 无锁环形缓冲区（Ring Buffer）与无锁队列的主要区别</strong></h3><ul>
<li><p><strong>参考答案</strong>：</p>
<ul>
<li><p><strong>无锁队列（基于链表）</strong>：</p>
<ul>
<li><p><strong>结构</strong>：动态节点，通过指针连接。</p>
</li>
<li><p><strong>核心挑战</strong>：管理动态内存的分配与回收（ABA问题）。</p>
</li>
<li><p><strong>操作</strong>：通过CAS原子性地修改 <code>head</code> 和 <code>tail</code> 指针。</p>
</li>
</ul>
</li>
<li><p><strong>无锁环形缓冲区（基于数组）</strong>：</p>
<ul>
<li><p><strong>结构</strong>：固定大小的数组，逻辑上首尾相连。</p>
</li>
<li><p><strong>核心挑战</strong>：<strong>区分“缓冲区满”和“缓冲区空”的状态</strong>（二者都是 <code>head == tail</code>）。通常的解决方案是：</p>
<ul>
<li><p>牺牲一个槽位。</p>
</li>
<li><p>使用一个独立的计数器记录数量。</p>
</li>
</ul>
</li>
<li><p><strong>操作</strong>：通过原子变量记录 <code>read_index</code> 和 <code>write_index</code>。生产者和消费者各自CAS地更新自己的索引。</p>
</li>
<li><p><strong>关键优势</strong>：<strong>内存连续，对Cache友好</strong>，非常适合作为固定大小的数据管道。<strong>它不需要处理动态内存分配，因此通常比链表实现更简单、性能更高。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>正确答案</strong>：（1）无锁RingBuffer原理：基于数组实现环形结构，通过<strong>两个原子变量（读指针r、写指针w）</strong> 控制读写，核心规则：</p>
<ul>
<li><p>写操作：通过CAS更新写指针w，确保多生产者（MP）安全；</p>
</li>
<li><p>读操作：通过CAS更新读指针r，确保多消费者（MC）安全；</p>
</li>
<li><p>空&#x2F;满判断：通过w - r &#x3D;&#x3D; 缓冲区大小（满）或w &#x3D;&#x3D; r（空），避免数据覆盖。</p>
</li>
</ul>
<p>（2）与无锁队列（链表实现）的核心区别：</p>
<p>无锁RingBuffer（数组）：存储结构为连续数组，内存开销低（无节点指针开销），访问效率高（缓存友好，连续访问），容量固定（需预分配），适用高频读写、固定数据量场景；</p>
<p>无锁队列（链表）：存储结构为离散节点，内存开销高（每个节点含指针），访问效率低（缓存不友好，离散访问），支持动态扩容，适用数据量不固定、需动态扩容场景。</p>
<ol start="7">
<li><h3 id="结构体（struct）和类（class）的继承区别是什么？"><a href="#结构体（struct）和类（class）的继承区别是什么？" class="headerlink" title="结构体（struct）和类（class）的继承区别是什么？"></a>结构体（struct）和类（class）的继承区别是什么？</h3></li>
</ol>
<p><strong>正确答案</strong>：核心区别仅在于<strong>默认访问权限和默认继承方式</strong>，其他语法完全一致（结构体可继承、可被继承，支持多态、虚函数等）：</p>
<ul>
<li><p>访问权限：struct成员默认public，class成员默认private；</p>
</li>
<li><p>继承方式：struct默认public继承，class默认private继承；</p>
</li>
</ul>
<p>示例：<br>    struct A {};struct B : A {}; &#x2F;&#x2F; 等价于 struct B : public A {}（public继承）class C : A {}; &#x2F;&#x2F; 等价于 class C : private A {}（private继承）</p>
<ol start="8">
<li><h3 id="函数签名由哪些部分构成？（写代码时哪些内容决定函数唯一性）"><a href="#函数签名由哪些部分构成？（写代码时哪些内容决定函数唯一性）" class="headerlink" title="函数签名由哪些部分构成？（写代码时哪些内容决定函数唯一性）"></a>函数签名由哪些部分构成？（写代码时哪些内容决定函数唯一性）</h3></li>
</ol>
<p><strong>正确答案</strong>：函数签名的核心构成：<strong>函数名 + 参数列表（参数类型、参数个数、参数顺序） + cv限定符（const&#x2F;volatile） + 引用限定符（&amp;&#x2F;&amp;&amp;）</strong>，<strong>返回值不参与函数签名构成</strong>。</p>
<p>关键细节：</p>
<ul>
<li><p>参数的左值&#x2F;右值属性属于参数类型的一部分（如void f(int&amp;)和void f(int&amp;&amp;)是不同签名）；</p>
</li>
<li><p>cv限定符仅针对成员函数（如void f() const和void f()是不同签名）；</p>
</li>
<li><p>示例：</p>
<ul>
<li><p>相同签名（错误，编译冲突）：int add(int a, int b) 和 double add(int a, int b)（仅返回值不同）；</p>
</li>
<li><p>不同签名（合法）：int add(int a, int b) 和 int add(double a, double b)（参数类型不同）。</p>
</li>
</ul>
</li>
</ul>
<ol start="9">
<li><h3 id="std-move和std-forward的底层实现与区别是什么？"><a href="#std-move和std-forward的底层实现与区别是什么？" class="headerlink" title="std::move和std::forward的底层实现与区别是什么？"></a>std::move和std::forward的底层实现与区别是什么？</h3></li>
</ol>
<p><strong>正确答案</strong>：（1）std::move：底层是<strong>无条件将左值强制转换为右值引用</strong>（无内存拷贝，仅类型转换），原型：<br>    template <typename T>typename std::remove_reference_t<T>&amp;&amp; move(T&amp;&amp; t) noexcept {    return static_cast&lt;typename std::remove_reference_t<T>&amp;&amp;&gt;(t);}</p>
<p>核心：不改变对象生命周期，仅“允许”后续代码移动其资源（是否移动取决于对象是否支持移动语义）。</p>
<p>（2）std::forward：底层是<strong>条件式类型转发（完美转发）</strong>，根据实参的左&#x2F;右值属性，将参数转发为对应类型，原型（简化）：<br>    template <typename T>T&amp;&amp; forward(typename std::remove_reference_t<T>&amp; t) noexcept {    return static_cast&lt;T&amp;&amp;&gt;(t);}</p>
<p>核心：解决“模板参数传递时左值被退化”的问题，仅用于模板函数的参数转发，需配合“万能引用（T&amp;&amp;）”使用。</p>
<p>区别：std::move是“无条件转换为右值”，std::forward是“有条件保留原类型转发”；move用于“放弃对象所有权”，forward用于“传递对象所有权而不改变其属性”。</p>
<ol start="10">
<li><h3 id="伪共享问题的定义及具体避免方法（含代码实现）？"><a href="#伪共享问题的定义及具体避免方法（含代码实现）？" class="headerlink" title="伪共享问题的定义及具体避免方法（含代码实现）？"></a>伪共享问题的定义及具体避免方法（含代码实现）？</h3></li>
</ol>
<p><strong>正确答案</strong>：（1）定义：多个线程访问<strong>不同数据，但这些数据被加载到同一个CPU Cache Line</strong>，导致Cache Line频繁失效（Invalidate），引发性能损耗的问题（本质是“缓存冲突”的一种）。</p>
<p>（2）避免方法（代码级落地）：</p>
<p>① Cache Line填充（最常用）：通过添加“无用填充字节”，让目标数据独占一个Cache Line（通常64字节）；</p>
<p>示例：<br>    &#x2F;&#x2F; 假设Cache Line为64字节，int占4字节，需填充60字节struct alignas(64) Data { &#x2F;&#x2F; 强制对齐到64字节    int value; &#x2F;&#x2F; 4字节    char padding[60]; &#x2F;&#x2F; 填充字节，确保value独占一个Cache Line};</p>
<p>② 内存对齐关键字：使用C++11的alignas指定对齐系数，或GCC的__attribute__((aligned(64)))；</p>
<p>③ 调整数据访问顺序：让不同线程访问的数据集分布在不同Cache Line（如矩阵按行优先访问而非列优先）。</p>
<ol start="11">
<li><h3 id="原子变量支持哪些数据类型？底层依赖什么？"><a href="#原子变量支持哪些数据类型？底层依赖什么？" class="headerlink" title="原子变量支持哪些数据类型？底层依赖什么？"></a>原子变量支持哪些数据类型？底层依赖什么？</h3></li>
</ol>
<p><strong>正确答案</strong>：（1）支持的数据类型：</p>
<ul>
<li><p>基础类型：bool、char、short、int、long、long long及其无符号版本，float、double（部分编译器支持，需硬件支持原子操作）；</p>
</li>
<li><p>指针类型：任意指针（T*）；</p>
</li>
<li><p>自定义类型：满足“可平凡复制（TriviallyCopyable）”的结构体&#x2F;类（需编译器和硬件支持，通常用于小于等于CPU位宽的类型）；</p>
</li>
</ul>
<p>核心限制：类型大小不能超过CPU的“原子操作支持位宽”（如32位CPU通常支持最大4字节原子类型，64位CPU支持8字节）。</p>
<p>（2）底层依赖：硬件提供的原子指令（如x86的LOCK前缀指令、ARM的LDREX&#x2F;STREX指令），无需操作系统内核介入（用户态实现），性能优于mutex。</p>
<ol start="12">
<li><h3 id="原子操作中内存序（memory-order）的选择场景：release、acquire分别用在什么场景？"><a href="#原子操作中内存序（memory-order）的选择场景：release、acquire分别用在什么场景？" class="headerlink" title="原子操作中内存序（memory order）的选择场景：release、acquire分别用在什么场景？"></a>原子操作中内存序（memory order）的选择场景：release、acquire分别用在什么场景？</h3></li>
</ol>
<p><strong>正确答案</strong>：内存序的核心目的是<strong>禁止编译器和CPU的指令重排</strong>，平衡“一致性”和“性能”，常见场景：</p>
<p>（1）std::memory_order_acquire（读操作）：</p>
<ul>
<li><p>适用场景：线程读取一个原子变量后，后续所有内存操作（读&#x2F;写）不能重排到该读操作之前；</p>
</li>
<li><p>典型用法：消费者线程读取“数据就绪”标记（原子变量），确保读取标记后能看到生产者线程之前写入的所有数据。</p>
</li>
</ul>
<p>（2）std::memory_order_release（写操作）：</p>
<ul>
<li><p>适用场景：线程写入一个原子变量前，所有之前的内存操作（读&#x2F;写）不能重排到该写操作之后；</p>
</li>
<li><p>典型用法：生产者线程写入数据后，更新“数据就绪”标记（原子变量），确保标记更新前的数据已全部写入内存。</p>
</li>
</ul>
<p>（3）组合场景：acquire-release配对（最常用），实现“happens-before”关系，示例：<br>    std::atomic<bool> ready(false);int data;&#x2F;&#x2F; 生产者线程data &#x3D; 10; &#x2F;&#x2F; 写数据ready.store(true, std::memory_order_release); &#x2F;&#x2F; 释放语义，data的写入不晚于store&#x2F;&#x2F; 消费者线程while (!ready.load(std::memory_order_acquire)); &#x2F;&#x2F; 获取语义，load后的数据读取不早于loadassert(data &#x3D;&#x3D; 10); &#x2F;&#x2F; 必然成立</p>
<p>（4）std::memory_order_seq_cst（默认，最严格）：仅在需要“全局顺序一致性”时使用（如多个线程竞争同一个资源且需严格顺序），性能开销最大。</p>
<ol start="13">
<li><h3 id="读写锁（shared-mutex）的适用场景是什么？自旋锁（spinlock）的适用场景是什么？"><a href="#读写锁（shared-mutex）的适用场景是什么？自旋锁（spinlock）的适用场景是什么？" class="headerlink" title="读写锁（shared_mutex）的适用场景是什么？自旋锁（spinlock）的适用场景是什么？"></a>读写锁（shared_mutex）的适用场景是什么？自旋锁（spinlock）的适用场景是什么？</h3></li>
</ol>
<p><strong>正确答案</strong>：（1）读写锁（shared_mutex）：</p>
<ul>
<li><p>核心特性：多读者（共享锁）、单写者（排他锁），读-读不互斥，读-写互斥，写-写互斥；</p>
</li>
<li><p>适用场景：<strong>读多写少</strong>的场景（如配置文件读取、缓存查询），避免写操作阻塞所有读操作，提升并发读性能；</p>
</li>
<li><p>反例：写操作频繁的场景（如高频数据更新），读写锁的切换开销会超过性能收益。</p>
</li>
</ul>
<p>（2）自旋锁（spinlock）：</p>
<ul>
<li><p>核心特性：线程获取锁失败时，不阻塞（不放弃CPU），而是循环重试（自旋），直到获取锁成功；</p>
</li>
<li><p>适用场景：① 锁持有时间极短（如仅修改一个原子变量）；② CPU核心数充足，自旋时不会导致其他线程饥饿；</p>
</li>
<li><p>反例：锁持有时间长（如IO操作），自旋会浪费CPU资源，此时应使用mutex（阻塞线程，释放CPU）。</p>
</li>
</ul>
<ol start="14">
<li><h3 id="问题：pthread-mutex的底层原理是什么？线程遇到已被占用的mutex时会做什么？"><a href="#问题：pthread-mutex的底层原理是什么？线程遇到已被占用的mutex时会做什么？" class="headerlink" title="问题：pthread_mutex的底层原理是什么？线程遇到已被占用的mutex时会做什么？"></a><strong>问题</strong>：pthread_mutex的底层原理是什么？线程遇到已被占用的mutex时会做什么？</h3></li>
</ol>
<p><strong>正确答案</strong>：（1）底层原理：pthread_mutex是POSIX标准的互斥锁，底层依赖<strong>操作系统内核的同步机制</strong>（如x86的futex、Linux的内核等待队列），分为“快速锁”和“慢速锁”：</p>
<ul>
<li><p>快速锁：基于原子操作（CAS）实现，无竞争时在用户态完成锁的获取&#x2F;释放，无需内核调用；</p>
</li>
<li><p>慢速锁：当锁存在竞争时，触发内核态切换，将等待线程放入内核等待队列，避免CPU自旋浪费。</p>
</li>
</ul>
<p>（2）线程获取已占用的mutex时的行为：</p>
<ul>
<li><p>非递归锁（默认）：线程会从用户态切换到内核态，被挂起（阻塞），放入内核等待队列，直到锁被释放后由内核唤醒；</p>
</li>
<li><p>递归锁（PTHREAD_MUTEX_RECURSIVE）：同一线程可多次获取锁，计数递增，释放时计数递减至0才释放锁，避免死锁。</p>
</li>
</ul>
<ol start="15">
<li><h3 id="问题：内存竞争（data-race）与内存冲突（segmentation-fault）的区别是什么？"><a href="#问题：内存竞争（data-race）与内存冲突（segmentation-fault）的区别是什么？" class="headerlink" title="问题：内存竞争（data race）与内存冲突（segmentation fault）的区别是什么？"></a><strong>问题</strong>：内存竞争（data race）与内存冲突（segmentation fault）的区别是什么？</h3></li>
</ol>
<p><strong>正确答案</strong>：（1）内存竞争（data race）：</p>
<ul>
<li><p>定义：多个线程同时访问同一个非原子变量，且至少有一个线程是写操作，未通过同步机制（mutex、原子操作）保护；</p>
</li>
<li><p>后果：未定义行为（UB），可能导致数据不一致、程序崩溃、结果随机，无固定报错信息；</p>
</li>
<li><p>示例：两个线程同时执行i++（i为int类型）。</p>
</li>
</ul>
<p>（2）内存冲突（segmentation fault，段错误）：</p>
<ul>
<li><p>定义：程序访问了非法内存地址（如空指针、野指针、越界访问、权限不足）；</p>
</li>
<li><p>后果：操作系统触发信号（SIGSEGV），程序直接崩溃，有明确报错信息（如core dump）；</p>
</li>
<li><p>示例：int* p &#x3D; nullptr; *p &#x3D; 10;（空指针解引用）。</p>
</li>
</ul>
<p>核心区别：内存竞争是“合法内存地址的并发访问问题”，内存冲突是“非法内存地址的访问问题”。</p>
<ol start="16">
<li><h3 id="如何用C-实现“二进制反序列化后，暴露为Python的pandas-DataFrame-x2F-numpy-ndarray”？（岗位核心场景）"><a href="#如何用C-实现“二进制反序列化后，暴露为Python的pandas-DataFrame-x2F-numpy-ndarray”？（岗位核心场景）" class="headerlink" title="如何用C++实现“二进制反序列化后，暴露为Python的pandas DataFrame&#x2F;numpy ndarray”？（岗位核心场景）"></a>如何用C++实现“二进制反序列化后，暴露为Python的pandas DataFrame&#x2F;numpy ndarray”？（岗位核心场景）</h3></li>
</ol>
<p><strong>正确答案</strong>：核心思路：C++负责二进制数据解析，通过<strong>Cython或PyBind11</strong>暴露C++接口给Python，将解析后的数据转换为Python可识别的格式：</p>
<p>（1）步骤拆解：</p>
<p>① C++端：读取二进制文件→反序列化（如Protobuf、自定义结构体）→将数据存储为连续内存（如std::vector<double>）；</p>
<p>② 接口暴露：用PyBind11将C++的连续内存数据封装为numpy ndarray（零拷贝，直接复用C++内存）；</p>
<p>③ Python端：将numpy ndarray转换为pandas DataFrame（无需拷贝，共享数据）。</p>
<p>（2）代码示例（PyBind11部分）：<br>    #include &lt;pybind11&#x2F;pybind11.h&gt;#include &lt;pybind11&#x2F;numpy.h&gt;#include <vector>namespace py &#x3D; pybind11;&#x2F;&#x2F; C++反序列化函数：返回连续内存数据std::vector<double> parse_binary(const std::string&amp; filename) {    std::vector<double> data;    &#x2F;&#x2F; 1. 读取二进制文件    &#x2F;&#x2F; 2. 反序列化（如解析自定义结构体）    &#x2F;&#x2F; 3. 填充data（连续内存）    return data;}&#x2F;&#x2F; 暴露接口给Python，转换为numpy ndarrayPYBIND11_MODULE(parser, m) {    m.def(“parse_binary”, [](const std::string&amp; filename) {        auto data &#x3D; parse_binary(filename);        &#x2F;&#x2F; 零拷贝创建numpy数组，复用C++ vector的内存        return py::array_t<double>(            data.size(), &#x2F;&#x2F; 数组大小            data.data()  &#x2F;&#x2F; 数据指针        );    });}</p>
<p>（3）Python端调用：<br>    import parserimport pandas as pdimport numpy as np# 调用C++接口，获取numpy数组（零拷贝）arr &#x3D; parser.parse_binary(“data.bin”)# 转换为DataFrame（无拷贝）df &#x3D; pd.DataFrame(arr.reshape(-1, 3), columns&#x3D;[“col1”, “col2”, “col3”])</p>

            
        </div>
        <div class="page-template-comments">
            
        </div>
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Ethereal</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br>
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.2.1</a>
        </div>
        
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/navbarShrink.js"></script>

<script src="/js/tools/scrollTopBottom.js"></script>

<script src="/js/tools/lightDarkSwitch.js"></script>





    
<script src="/js/tools/codeBlock.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/libs/Typed.min.js"></script>

  
<script src="/js/plugins/typed.js"></script>







<div class="post-scripts pjax">
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
